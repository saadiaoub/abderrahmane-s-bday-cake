<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üéÇ Magical Birthday Cake</title>
<style>
  body {
    margin: 0; background: #f0e6f6;
    overflow: hidden;
    font-family: 'Comic Sans MS', sans-serif;
  }
  #message {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px; color: #333; text-align: center;
    display: none;
    background: rgba(255,255,255,0.8); padding: 10px 20px; border-radius: 10px;
  }
  canvas { display: block; }
</style>
</head>
<body>
<div id="message">üßö‚Äç‚ôÄÔ∏è The fairies have gotten your wishes üßö‚Äç‚ôÄÔ∏è</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script>
let scene, camera, renderer, cake, frosting, controls;
let candles = [];
let flames = [];
let blownOut = false;

// Create scene
scene = new THREE.Scene();
scene.background = new THREE.Color('#f0e6f6');

// Camera
camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 10);

// Renderer
renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Controls
controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;

// Lights
const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
dirLight.position.set(5,10,7);
scene.add(dirLight);

// Cake (cylinder)
const cakeGeo = new THREE.CylinderGeometry(2,2,2,64,1,true);
const cakeMat = new THREE.MeshPhongMaterial({color:0x1a4a80});
cake = new THREE.Mesh(cakeGeo, cakeMat);
cake.position.y = 1;
scene.add(cake);

// Frosting (slightly bigger, top)
const frostingGeo = new THREE.TorusGeometry(2.05,0.15,16,100);
const frostingMat = new THREE.MeshPhongMaterial({color:0x90caf9});
frosting = new THREE.Mesh(frostingGeo, frostingMat);
frosting.rotation.x = Math.PI/2;
frosting.position.y = 2;
scene.add(frosting);

// Read candles from URL
const params = new URLSearchParams(window.location.search);
const candleStr = params.get('candles');
if (candleStr) {
  const arr = candleStr.split(',').map(Number);
  arr.forEach(angle => addCandle(angle));
}

// Resize
window.addEventListener('resize', ()=> {
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// Click to add candle
window.addEventListener('click', e=>{
  if(blownOut) return; // don't add after blowing
  // calculate angle on top circle based on click x
  const angle = Math.random()*2*Math.PI;
  candles.push(angle);
  addCandle(angle);
  updateURL();
});

// Add single candle
function addCandle(angle){
  const x=2*Math.cos(angle);
  const z=2*Math.sin(angle);
  const candleGeo=new THREE.CylinderGeometry(0.05,0.05,0.5,8);
  const candleMat=new THREE.MeshPhongMaterial({color:0xffffff});
  const candleMesh=new THREE.Mesh(candleGeo,candleMat);
  candleMesh.position.set(x,2.25,z);
  scene.add(candleMesh);
  // flame
  const flameGeo=new THREE.SphereGeometry(0.08,8,8);
  const flameMat=new THREE.MeshBasicMaterial({color:0xffaa00});
  const flameMesh=new THREE.Mesh(flameGeo,flameMat);
  flameMesh.position.set(x,2.55,z);
  scene.add(flameMesh);
  flames.push(flameMesh);
}

// Update URL
function updateURL(){
  const str=candles.map(a=>a.toFixed(3)).join(',');
  const newUrl=window.location.origin+window.location.pathname+'?candles='+str;
  window.history.replaceState({},'',newUrl);
}

// Blow detection
async function setupMic(){
  try{
    const stream=await navigator.mediaDevices.getUserMedia({audio:true});
    const audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    const source=audioCtx.createMediaStreamSource(stream);
    const analyser=audioCtx.createAnalyser();
    source.connect(analyser);
    const data=new Uint8Array(analyser.fftSize);

    function check(){
      analyser.getByteTimeDomainData(data);
      let sum=0;
      for(let i=0;i<data.length;i++){sum+=Math.abs(data[i]-128);}
      const volume=sum/data.length;
      if(volume>10 && !blownOut){
        blownOut=true;
        flames.forEach(f=>scene.remove(f));
        document.getElementById('message').style.display='block';
      }
      requestAnimationFrame(check);
    }
    check();
  }catch(e){console.error(e);}
}
setupMic();

// Animate
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
