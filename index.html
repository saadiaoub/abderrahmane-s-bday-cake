<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üéÇ Magical 3D Birthday Cake</title>
<style>
  body { margin: 0; background: #f0e6f6; overflow: hidden; font-family: sans-serif; }
  #message {
    display: none;
    position: absolute;
    top: 20px; left: 50%;
    transform: translateX(-50%);
    color: #333; font-size: 20px; text-align: center;
    background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px;
  }
</style>
</head>
<body>
<div id="message">üßö‚Äç‚ôÄÔ∏è The fairies have gotten your wishes üßö‚Äç‚ôÄÔ∏è</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let cake, frosting;
let candles = [];
let blownOut = false;
const params = new URLSearchParams(window.location.search);
const candleStr = params.get('candles');
const message = document.getElementById('message');

init();
if (candleStr) {
  candles = candleStr.split(',').map(pos => parseFloat(pos));
  drawCandles();
}
animate();
setupMic();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 2.5, 5); // move back & up to see whole cake

  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(5,5,5);
  scene.add(dirLight);

  // cake base
  const cakeGeo = new THREE.CylinderGeometry(1.5,1.5,1,64,1,true);
  const cakeMat = new THREE.MeshPhongMaterial({ color: 0x1a237e, shininess: 30 });
  cake = new THREE.Mesh(cakeGeo, cakeMat);
  scene.add(cake);

  // frosting with wavy effect
  frosting = createFrosting();
  frosting.position.y = 0.6;
  scene.add(frosting);

  // adjust on resize
  window.addEventListener('resize', onWindowResize, false);

  // click to add candle
  window.addEventListener('click', onClick);
}

function createFrosting() {
  // create a wavy ring frosting
  const geometry = new THREE.RingGeometry(0.8,1.55,32,1,0,Math.PI*2);
  const positions = geometry.attributes.position.array;
  for (let i = 0; i < positions.length; i += 3) {
    positions[i+2] += 0.1*Math.sin(i); // wave effect
  }
  const mat = new THREE.MeshPhongMaterial({ color: 0x90caf9, side: THREE.DoubleSide, shininess: 60 });
  return new THREE.Mesh(geometry, mat);
}

function drawCandles() {
  candles.forEach(c => scene.remove(c.mesh, c.flame));
  candles = candles.map(x => {
    const angle = (x/100)*2*Math.PI;
    const r = 1.2;
    const cx = Math.cos(angle)*r;
    const cz = Math.sin(angle)*r;

    const candleGeo = new THREE.CylinderGeometry(0.05,0.05,0.3,16);
    const candleMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const candleMesh = new THREE.Mesh(candleGeo, candleMat);
    candleMesh.position.set(cx,0.8,cz);

    // flame
    const flameGeo = new THREE.SphereGeometry(0.05,8,8);
    const flameMat = new THREE.MeshBasicMaterial({ color: 0xffd54f });
    const flame = new THREE.Mesh(flameGeo, flameMat);
    flame.position.set(cx,0.95,cz);
    if (!blownOut) scene.add(flame);
    scene.add(candleMesh);
    return { x, mesh: candleMesh, flame };
  });
}

function onClick(e) {
  if (e.target !== renderer.domElement) return;
  const xPercent = Math.random()*100;
  candles.push({ x: xPercent });
  blownOut = false;
  message.style.display = 'none';
  updateURL();
  drawCandles();
}

function updateURL() {
  const str = candles.map(c => c.x.toFixed(1)).join(',');
  const newUrl = window.location.origin + window.location.pathname + '?candles=' + str;
  window.history.replaceState({}, '', newUrl);
}

function animate() {
  requestAnimationFrame(animate);
  cake.rotation.y += 0.002;
  frosting.rotation.y += 0.002;
  if (!blownOut) {
    candles.forEach(c => {
      c.flame.scale.y = 1 + Math.sin(Date.now()*0.01 + c.x) *0.2;
    });
  }
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

async function setupMic() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(stream);
    const analyser = audioCtx.createAnalyser();
    source.connect(analyser);
    const data = new Uint8Array(analyser.fftSize);

    function checkVolume() {
      analyser.getByteTimeDomainData(data);
      let sum = 0;
      for (let i = 0; i < data.length; i++) {
        sum += Math.abs(data[i] - 128);
      }
      const volume = sum / data.length;
      if (volume > 10 && !blownOut) {
        blownOut = true;
        message.style.display = 'block';
        candles.forEach(c => scene.remove(c.flame));
      }
      requestAnimationFrame(checkVolume);
    }
    checkVolume();
  } catch (err) {
    console.error('Mic access denied or error:', err);
  }
}
</script>
</body>
</html>
